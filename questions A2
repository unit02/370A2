How well would this synchronisation implementation cope with a large number of files? Explain your
answer. 

Scaliability to bad, due to to iterative nature of this implementation. Manually checkng every single modification date would take a significant amount of time to perform, and it prone to errors. A better implementation would not rely on comparing every file on each system, and rather compare only those files that have been affected. 

Several of the assumptions cannot be enforced. We rely on the user being careful. This is partly becauseof the limitations of most current file systems. Take two of the assumptions above (you may also specify other assumptions that I haven't explicitly mentioned), and describe ways in which the assumptions can be made unnecessary. Your solutions should make the synchronization process safer or more reliable. At least one of the solutions should mention some extra facility that must be added to the file system to make the solution possible. 

1) The assumption regarding the pathnames being independent cannot be enforced in a real system. Users are likely to cause infinite recursion by storing directories inside on another, which would break this implementation of a file synchronization service. A solution to this is to give directories a level number relative to how "Far" it is form the home directory (eg Documents will be 1). Once a level number has been assigned, it cannot be changed. The system can check when a user is trying to move a directory, and if it's level number is lower than the directory it is trying to move to, then the user will face an error. This is not a very practical solution, but is possible.

2) The assumption that files on one directory are named the same as subdirectories in the other directory is very limiting, as standard users would often meet this situation. A unique id generator could be used to generate identification codes for all files and directories, with a special identifier to use for when it's a file or a directory. This would allow the code to check what type of file it is, and thus understand that they are not the same. This can also be used to identify if files are the same of not, in the same way the digest worked for this assignment.
